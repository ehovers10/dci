# Introduction

cooperative principle:
  "Make your conversational contribution such as is required, at the stage at which it occurs, by the accepted purpose or direction of the talk exchange in which you are engaged."

collaborative principle:
  "Make your conversational effort such that, together with your interlocutors' efforts, it advances the inquiry along the accepted purpose or direction of the talk exchange in which you all are engaged."

# Knowledge in the image of inquiry

levi identity:
  "Conceived semantically, all rational information state revision is reducible to some combination of set intersection and union among information states and propositions."

jamesian amendment:
  "Rational information state revision is governed by two goals: avoiding error and acquiring truth."

"van fraassen's first way":
  "An epistemology must imply that, and show how, epistemic security is humanly attainable by the methods of the sciences, under favorable conditions, and that it is in fact attained to some reasonable degree. Security means here, possibly knowledge, perhaps certainty, but at least reliable and accurate beliefs and opinions."

# Collaborative discourse dynamics

constraints on a theory of meaning:
  charity: "The attitudes determined by the system are more or less the beliefs and desires we would have were we to be in the speaker's position, broadly construed."
  rationalization: "The system supplies beliefs and desires that generally represent the speaker as having good reason for performing the actions he performs."
  truthfulness: "The system assigns meanings that accord with the speaker participating in a convention of truthfulness with other speakers of his language."
  generativity: "The complete system of meanings is at least finitely specifiable, and perhaps also reasonably uniform and simple."
  manifestation: "The beliefs and desires that the system maintains are held by the speaker are revealed in his dispositions to speech behavior."
  triangulation: "The system provides meanings that link the specifications of the speaker's beliefs and desires in both their language and the theorizer's."

# Dispute in discourse

focus:
  -
    - "<span class='set'>D</span> a domain of discourse"
    - "<span class='var'>t</span> a type"
  - fxn: eqn
    arg:
      lhs:
        - fxn: semwrap
          arg:
            inside: "&phi;<sub>t</sub>"
            outside: "<sup>f</sup>"
      conn: =
      rhs:
        - fxn: curlywrap
          arg:
            inside:
              - fxn: eqn
                arg:
                  lhs: d
                  conn: "&isin;"
                  rhs: "<span class='set'>D</span><sub>t</sub>"

qa-congruence:
  -
    - "&#x27e8; &psi;, &alpha; &#x27e9; a question/answer pair"
  - fxn: eqn
    arg:
      lhs:
        - fxn: semwrap
          arg:
            inside: "&psi;"
            outside: "<sup>o</sup>"
      conn: "&sube;"
      rhs:
        - fxn: semwrap
          arg:
            inside: "&alpha;"
            outside: "<sup>f</sup>"

homogeneity:
  def: "Utterances involving bare plural subjects present the set determined by the
       subject as homogenous with respect to the predicate. The predicate applies
       either to all members of the subject class or to none of them."
  form: "[&forall; x &isin; f(w)(p): q(x)] &or; [&forall; x &isin; f(w)(p): &not;q(x)]"

counterfactual conditional:
  english:
    -
      - "If had &#x231c;A&#x231d;, would have &#x231c;B&#x231d;"

  strict:
    - translation:
        - "A &#x297d; B"
    - definition:
      -
        - "A,B: st"
      - fxn: eqn
        arg:
          lhs: "A &#x297d; B"
          conn: =
          rhs:
            - fxn: eqn
              arg:
                lhs: "1"
                conn: if
                rhs: "&#x27e6;&nbsp;A&nbsp;&#x27e7;<sup>i</sup>&nbsp;&sube;&nbsp;&#x27e6;&nbsp;B&nbsp;&#x27e7;<sup>i</sup>"
            - fxn: eqn
              arg:
                lhs: "0"
                conn: otherwise
                rhs: "&nbsp;"

  thinning:
    - fxn: eqn
      arg:
        lhs: "A &#x297d; B"
        conn: "&rArr;"
        rhs: "&#x27e6;&nbsp;A&nbsp;&#x27e7;<sup>i</sup>&nbsp;&sube;&nbsp;&#x27e6;&nbsp;B&nbsp;&#x27e7;<sup>i</sup>"
    - fxn: eqn
      arg:
        lhs: "&nbsp;"
        conn: "&rArr;"
        rhs: "&#x27e6;&nbsp;A &and; C&nbsp;&#x27e7;<sup>i</sup>&nbsp;&sube;&nbsp;&#x27e6;&nbsp;B&nbsp;&#x27e7;<sup>i</sup>"
    - fxn: eqn
      arg:
        lhs: "&nbsp;"
        conn: "&rArr;"
        rhs: "&#x27e6;&nbsp;(A &and; C) &#x297d; B&nbsp;&#x27e7;<sup>i</sup>"

  variable:
    - translation:
      - fxn: eqn
        arg:
          lhs: A
          conn: "<span style='letter-spacing:-4px;'>&#x25a1;&rarr;</span>"
          rhs: B
    - definition:
      -
        - "A,B: <span class='type'>st</span>"
        - "&delta;(i): <span class='type'>st</span> &rarr; <span class='type'>st</span> a selection function determined by context <span class='var'>i</span>"
      - fxn: eqn
        arg:
          lhs: "A<sub>pref</sub>"
          conn: =
          rhs: "&delta;(i)(A)"
      - fxn: eqn
        arg:
          lhs:
            - fxn: eqn
              arg:
                lhs: A
                conn: "<span style='letter-spacing:-4px;'>&#x25a1;&rarr;</span>"
                rhs: B
          conn: =
          rhs:
            - fxn: eqn
              arg:
                lhs: "1"
                conn: if
                rhs: "&#x27e6;&nbsp;A<sub>pref</sub>&nbsp;&#x27e7;<sup>i</sup>&nbsp;&sube;&nbsp;&#x27e6;&nbsp;B&nbsp;&#x27e7;<sup>i</sup>"
            - fxn: eqn
              arg:
                lhs: "0"
                conn: otherwise
                rhs: "&nbsp;"

  shifty:
    - translation:
      - fxn: eqn
        arg:
          lhs: A
          conn: "&#x297d;<sub>s</sub>"
          rhs: B
    - definition:
      -
        - "i<sub>s</sub>: <span class='type'>st</span>"
        - "A,B: <span class='type'>st</span>"
        - "*&delta;(i): <span class='type'>st</span> &rarr; <span class='type'>st</span> a selection function determined by context <span class='var'>i</span>"
      - fxn: eqn
        arg:
          lhs: "&delta;(i)(A)"
          conn: "&sube;"
          rhs: "&#x27e6;&nbsp;A&nbsp;&#x27e7;<sup>i</sup>"
      - fxn: eqn
        arg:
          lhs: "i<sub>s</sub><sup>+</sup>(A)"
          conn: =
          rhs: "i<sub>s</sub><sup>+</sup>(A) &cap; &delta;(i)(A)"
      - fxn: eqn
        arg:
          lhs:
            - fxn: eqn
              arg:
                lhs: A
                conn: "&#x297d;<sub>s</sub>"
                rhs: B
          conn: =
          rhs:
            - fxn: eqn
              arg:
                lhs: "1"
                conn: if
                rhs: "&#x27e6;&nbsp;A&nbsp;&#x27e7;<sup>i</sup>&nbsp;&sube;&nbsp;&#x27e6;&nbsp;B&nbsp;&#x27e7;<sup>i[i<sub>s</sub>&rarr;i<sub>s</sub><sup>+</sup>(A)]</sup>"
            - fxn: eqn
              arg:
                lhs: "0"
                conn: otherwise
                rhs: "&nbsp;"

universal quantifier:
  english:
    -
      - "&#x231c;As&#x231d; are &#x231c;B&#x231d;"
  strict:
    - translation:
      - "&forall;(A)(B)"
    - definition:
      -
        - "A,B: <span class='type'>et</span>"
      - fxn: eqn
        arg:
          lhs: "&forall;(A)(B)"
          conn: =
          rhs:
            - fxn: eqn
              arg:
                lhs: "1"
                conn: if
                rhs:
                  - "&#x27e6;&nbsp;A&nbsp;&#x27e7;<sup>i</sup>&nbsp;&sube;&nbsp;&#x27e6;&nbsp;B&nbsp;&#x27e7;<sup>i</sup>"
            - fxn: eqn
              arg:
                lhs: "0"
                conn: otherwise
                rhs: "&nbsp;"

  generic:
    - translation:
      - "GEN(A)(B)"
    - definiton:
      -
        - "*A,B: et*"
        - "*&delta;(i): et* &rarr; *et* a selection function determined by context *i*"
      - fxn: eqn
        arg:
          lhs: "A<sub>pref</sub>"
          conn: =
          rhs:
            - "&delta;(i)(A)"
      - fxn: eqn
        arg:
          lhs: "GEN(A)(B)"
          conn: =
          rhs:
            - fxn: eqn
              arg:
                lhs: "1"
                conn: if
                rhs:
                  - "&#x27e6;&nbsp;A<sub>pref</sub>&nbsp;&#x27e7;<sup>i</sup>&nbsp;&sube;&#x27e6;&nbsp;B&nbsp;&#x27e7;<sup>i</sup>"
            - fxn: eqn
              arg:
                lhs: "0"
                conn: otherwise
                rhs: "&nbsp;"

  structural:
    - translation:
      - "&forall;<sub>**R**</sub>(A)(B)"
    - definition:
      -
        - "A: et"
        - "B: (et)t"
      - fxn: eqn
        arg:
          lhs: "&forall;<sub>**R**</sub>(A)(B)"
          conn: =
          rhs:
            - fxn: eqn
              arg:
                lhs: "1"
                conn: if
                rhs:
                  - "{ &#x27e6;&nbsp;A&nbsp;&#x27e7; } &isin; **R**"
                  - "&#x27e6;&nbsp;A&nbsp;&#x27e7; &sube; &#x27e6;&nbsp;B&nbsp;&#x27e7;"
            - fxn: eqn
              arg:
                lhs: "0"
                conn: otherwise
                rhs: "&nbsp;"

downdate:
  -
    - "&phi;,&psi;,&chi;: <span class='var'>drs</span>"
  - fxn: eqn
    arg:
      lhs:
        - fxn: eqn
          arg:
            lhs: "&chi;"
            conn: "&#x2291;"
            rhs: "&phi;"
      conn: iff
      rhs: "&exist;m [ ( m &isin; &phi;<sup>d</sup> &and; m &isin; &chi;<sup>d</sup> ) &or; ( m &isin; &phi;<sup>c</sup> &and; m &isin; &chi;<sup>c</sup> ) ]"
  - fxn: eqn
    arg:
      lhs:
        - fxn: eqn
          arg:
            lhs: "&chi;"
            conn: =
            rhs: "max(&phi;)"
      conn: iff
      rhs: "&chi;  &#x2291; &phi; &and; &forall;<span class='var'>c</span> &isin; &phi;<sup>c</sup> [ entrench(<span class='var'>c</span>) ] &and; &not;&exist;&phi; ( &psi;  &#x2291; &phi; &and; &chi;  &#x2291; &psi; )"
  - fxn: eqn
    arg:
      lhs:
        - fxn: eqn
          arg:
            lhs: "&phi;"
            conn: "&#x229E;"
            rhs: "&psi;"
      conn: =
      rhs:
        - fxn: drswrap
          arg:
            dref: "&phi;<sup>d</sup> &oplus; S<sup>d</sup>"
            conditions: "&phi;<sup>c</sup> &oplus; S<sup>c</sup>"
  - fxn: eqn
    arg:
      lhs:
        - fxn: eqn
          arg:
            lhs: "&phi;"
            conn: "<span class='symbol'>&darr;</span>"
            rhs: "&psi;"
      conn: =
      rhs: "&psi; &oplus; max( &chi; &#x2291; &phi; | &chi; &#x229E; &phi; &ne; &empty; )"
